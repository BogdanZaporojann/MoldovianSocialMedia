{"ast":null,"code":"import e from \"compute-scroll-into-view\";\n\nlet t = e => !1 === e ? {\n  block: \"end\",\n  inline: \"nearest\"\n} : (e => e === Object(e) && 0 !== Object.keys(e).length)(e) ? e : {\n  block: \"start\",\n  inline: \"nearest\"\n};\n\nfunction o(o, l) {\n  let n = o.isConnected || o.ownerDocument.documentElement.contains(o);\n  if ((e => \"object\" == typeof e && \"function\" == typeof e.behavior)(l)) return l.behavior(n ? e(o, l) : []);\n  if (!n) return;\n  let r = t(l),\n      c = e(o, r),\n      i = (\"scrollBehavior\" in document.body.style);\n  c.forEach(e => {\n    let {\n      el: t,\n      top: o,\n      left: l\n    } = e;\n    t.scroll && i ? t.scroll({\n      top: o,\n      left: l,\n      behavior: r.behavior\n    }) : (t.scrollTop = o, t.scrollLeft = l);\n  });\n}\n\nexport { o as default };","map":{"version":3,"mappings":";;AA6BA,IAUIA,IAAcC,MAEA,CAFAA,KAEZA,CAFYA,GAGP;EAAEC,OAAO,KAAT;EAAgBC,QAAQ;AAAxB,CAHOF,GAThBA,MAEAA,MAAYG,OAAOH,CAAPG,CAAZH,IAA+D,MAAhCG,OAAOC,IAAPD,CAAYH,CAAZG,EAAqBE,MAFpDL,EAe6BA,CAf7BA,IAiBSA,CAjBTA,GAqBO;EAAEC,OAAO,OAAT;EAAkBC,QAAQ;AAA1B,CAtBT;;AAuCwB,WACtBI,CADsB,EAEtBN,CAFsB,EAEtBA;EAGA,IAAIO,IACFD,EAAOE,WAAPF,IACAA,EAAOG,aAAPH,CAAsBI,eAAtBJ,CAAuCK,QAAvCL,CAAgDA,CAAhDA,CAFF;EAII,IA1CJN,MAEmB,mBAAZA,CAAY,IAAuC,qBAArBA,EAAQY,QAF7CZ,EA0C8BA,CA1C9BA,CA0CI,EACK,SAAQY,QAARZ,CAAiBO,IAAmBM,EAAQP,CAARO,EAAgBb,CAAhBa,CAAnBN,GAA8C,EAA/DP;EAIT,KAAKO,CAAL,EACE;EAIE,QAAiBR,EAAWC,CAAXD,CAAjB;EAAA,IACAe,IAAUD,EAAQP,CAARO,EAAgBE,CAAhBF,CADV;EAAA,IAEAG,KAAkB,oBAAoBC,SAASC,IAATD,CAAcE,KAApDH,CAFA;EAIJF,EAAQM,OAARN,CAAgBO;IAAuB;MAAtBC,IAAEA,CAAoB;MAAhBC,MAAgB;MAAhBC,MAAKA;IAAW;IAGjCF,EAAGG,MAAHH,IAAaN,CAAbM,GACFA,EAAGG,MAAHH,CAAU;MAAEC,MAAF;MAAOC,OAAP;MAAaZ,UAAUG,EAAeH;IAAtC,CAAVU,CADEA,IAGFA,EAAGI,SAAHJ,GAAeC,CAAfD,EACAA,EAAGK,UAAHL,GAAgBE,CAJdF;EAKJ,CARFR;AAUF;;AAAA","names":["getOptions","options","block","inline","Object","keys","length","target","isTargetAttached","isConnected","ownerDocument","documentElement","contains","behavior","compute","actions","computeOptions","canSmoothScroll","document","body","style","forEach","_ref","el","top","left","scroll","scrollTop","scrollLeft"],"sources":["C:\\Users\\37360\\Desktop\\Lucru\\MoldovianSocialMedia\\node_modules\\scroll-into-view-if-needed\\src\\index.ts"],"sourcesContent":["import compute from 'compute-scroll-into-view'\nimport type {\n  Options as BaseOptions,\n  ScrollAction,\n} from 'compute-scroll-into-view'\n\n/** @public */\nexport type Options<T = unknown> =\n  | StandardBehaviorOptions\n  | CustomBehaviorOptions<T>\n\n/** @public */\nexport interface StandardBehaviorOptions extends BaseOptions {\n  /**\n   * @defaultValue 'auto\n   */\n  behavior?: ScrollBehavior\n}\n\n/** @public */\nexport interface CustomBehaviorOptions<T = unknown> extends BaseOptions {\n  behavior: CustomScrollBehaviorCallback<T>\n}\n\n/** @public */\nexport type CustomScrollBehaviorCallback<T = unknown> = (\n  actions: ScrollAction[]\n) => T\n\nlet isStandardScrollBehavior = (\n  options: any\n): options is StandardBehaviorOptions =>\n  options === Object(options) && Object.keys(options).length !== 0\n\nlet isCustomScrollBehavior = <T = unknown>(\n  options: any\n): options is CustomBehaviorOptions<T> =>\n  typeof options === 'object' ? typeof options.behavior === 'function' : false\n\nlet getOptions = (options: any): StandardBehaviorOptions => {\n  // Handle alignToTop for legacy reasons, to be compatible with the spec\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  if (isStandardScrollBehavior(options)) {\n    // compute.ts ensures the defaults are block: 'center' and inline: 'nearest', to conform to the spec\n    return options\n  }\n\n  // if options = {}, options = true or options = null, based on w3c web platform test\n  return { block: 'start', inline: 'nearest' }\n}\n\n// Some people might use both \"auto\" and \"ponyfill\" modes in the same file, so we also provide a named export so\n// that imports in userland code (like if they use native smooth scrolling on some browsers, and the ponyfill for everything else)\n// the named export allows this `import {auto as autoScrollIntoView, ponyfill as smoothScrollIntoView} from ...`\n/** @public */\nexport default function scrollIntoView<T>(\n  target: Element,\n  options: CustomBehaviorOptions<T>\n): T\n/** @public */\nexport default function scrollIntoView(\n  target: Element,\n  options?: StandardBehaviorOptions | boolean\n): void\n/** @public */\nexport default function scrollIntoView<T = unknown>(\n  target: Element,\n  options?: StandardBehaviorOptions | CustomBehaviorOptions<T> | boolean\n): T | void {\n  // Browsers treats targets that aren't in the dom as a no-op and so should we\n  let isTargetAttached =\n    target.isConnected ||\n    target.ownerDocument!.documentElement!.contains(target)\n\n  if (isCustomScrollBehavior<T>(options)) {\n    return options.behavior(isTargetAttached ? compute(target, options) : [])\n  }\n\n  // Don't do anything if using a standard behavior on an element that is not in the document\n  if (!isTargetAttached) {\n    return\n  }\n\n  // @TODO see if it's possible to avoid this assignment\n  let computeOptions = getOptions(options)\n  let actions = compute(target, computeOptions)\n  let canSmoothScroll = 'scrollBehavior' in document.body.style\n\n  actions.forEach(({ el, top, left }) => {\n    // browser implements the new Element.prototype.scroll API that supports `behavior`\n    // and guard window.scroll with supportsScrollBehavior\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({ top, left, behavior: computeOptions.behavior })\n    } else {\n      el.scrollTop = top\n      el.scrollLeft = left\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"module"}